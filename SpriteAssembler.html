<html>

<head>
  <!-- load js files generated by convertSSBP.py -->
  <script src="cellsArray.js"></script>
  <script src="textureURLArray.js"></script>
  <script src="partsJSON.js"></script>
  <script src="initialAnimeJSON.js"></script>
  <script src="framesJSON.js"></script>

  <style>
    body {
      font-family: sans-serif;
    }

    hr {
      height: 0;
      border: 0;
      border-top: 6px solid #000;
    }

    .ctn {
      display: inline-block;
      margin: 15px;
    }

    .btn {
      background-color: #000;
      color: #fff;
      border: 0;
      padding: 10px 30px;
      font-size: 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      white-space: nowrap;
    }

    .btn:hover {
      background-color: lime;
      color: #000;
    }
  </style>
</head>

<body>
  <h1 id="title"></h1>
  <hr>
  <br>
  <h1> TEXTURES </h1>
  <div id="sprite-sheet-wrapper"></div>
  <br>
  <hr>

  <h1> CELLS </h1>
  <button id="pivot-btn" class="btn"> SHOW PIVOT </button>
  <br>
  <br>
  <div id="cells-wrapper"></div>
  <br>
  <hr>
  <br>

  <button id="grid-btn" class="btn"> SHOW GRID </button>
  <br>
  <br> Width: <input id="width-input" type="text" value="800"> Height: <input id="height-input" type="text" value="800">
  <br>
  <br> X: <input id="x-input" type="text" value="0"> Y: <input id="y-input" type="text" value="0">
  <br>
  <br>
  <button id="resize-btn" class="btn"> RESIZE </button>
  <div id="assembled-wrapper"></div>

  <script>
    var WIDTH = parseInt(document.getElementById('width-input').value);
    var HEIGHT = parseInt(document.getElementById('height-input').value);

    var STARTX = parseInt(document.getElementById('x-input').value);
    var STARTY = -parseInt(document.getElementById('y-input').value);

    var cells = cellsArray;

    function drawCells(showPivot = false) {
      for (var i = 0; i < cellsArray.length; i++) {
        var cellCtn = document.createElement('div');
        cellCtn.classList.add('ctn');
        document.getElementById('cells-wrapper').appendChild(cellCtn);

        var num = document.createElement('h2');
        num.innerHTML = i;
        cellCtn.appendChild(num);

        var cellName = document.createElement('div');
        cellName.innerHTML = cellsArray[i]["name"];
        cellCtn.appendChild(cellName);

        var canvas = document.createElement('canvas');
        canvas.id = 'cell-num-' + i;
        canvas.width = cellsArray[i].sizeX;
        canvas.height = cellsArray[i].sizeY;
        canvas.style.border = '1px solid #000';
        cellCtn.appendChild(canvas);

        var ctx = canvas.getContext("2d");

        var imagePath = cellsArray[i].cellMapData.imagePath;
        var texId = imagePath.substring(imagePath.lastIndexOf('/') + 1, imagePath.lastIndexOf('.'));
        var tex = document.getElementById(texId);

        try {
          ctx.drawImage(tex, -cellsArray[i]["posX"], -cellsArray[i]["posY"]);

          if (showPivot) {
            var cx = cellsArray[i].sizeX / 2;
            var cy = cellsArray[i].sizeY / 2;

            var pivotX = cellsArray[i].pivotX * cx * 2;
            var pivotY = cellsArray[i].pivotY * cy * 2;

            ctx.translate(cx, cy);
            ctx.beginPath();
            ctx.arc(pivotX, pivotY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "lime";
            ctx.fill();

            ctx.beginPath();
            ctx.arc(pivotX, pivotY, 3, 0, 2 * Math.PI);
            ctx.fillStyle = "fuchsia";
            ctx.fill();
          }

        } catch (error) {
          console.log('[drawCell() Err]: texId=', texId);
        }
      }
    }

    function drawPartAt(animation, animIndex, parentPosition, parts, ctx) {
      var currentAnim = animation[animIndex];
      var part = parts[animIndex];
      var cellIndex = currentAnim.cellIndex;

      var dx = currentAnim.posX / 10;
      var dy = currentAnim.posY / 10;
      var angle = currentAnim.rotationZ;

      var px = parentPosition.x;
      var py = parentPosition.y;
      var pAngle = parentPosition.rotationZ;
      var pScaleX = parentPosition.scaleX;
      var pScaleY = parentPosition.scaleY;

      var svgData = '';

      if (cellIndex > -1 && part.partType != 0 && !(currentAnim.flags & 1)) {
        var cell = cells[cellIndex];

        // set part's origin at center of cell
        var cx = -cell.sizeX / 2;
        var cy = -cell.sizeY / 2;

        // get pivot position
        var pivotX = cell.pivotX * cell.sizeX;
        var pivotY = cell.pivotY * cell.sizeY;

        // set part's origin at pivot
        var offsetX = cx - pivotX;
        var offsetY = cy - pivotY;

        ctx.save();

        for (var i = 0; i < px.length; i++) {

          ctx.translate(px[i], -py[i]);
          ctx.rotate(-pAngle[i] * Math.PI / 180);

          var scaleX = 1;
          var scaleY = 1;
          if (pScaleX[i] == -1) {
            ctx.scale(-1, 1);
            scaleX = -1;
          }
          if (pScaleY[i] == -1) {
            ctx.scale(1, -1);
            scaleY = -1;
          }

          svgData += '<g transform="translate(' + px[i] + ' ' + -py[i] + ') rotate(' + -pAngle[i] + ') scale(' + scaleX + ' ' + scaleY + ')">';
        }
        // console.log(svgData);

        ctx.translate(dx, -dy);
        ctx.rotate(-angle * Math.PI / 180);

        var flipH = 1;
        var flipV = 1;
        if (currentAnim.flags & (1 << 1)) {
          ctx.scale(-1, 1);
          flipH = -1;
        }
        if (currentAnim.flags & (1 << 2)) {
          ctx.scale(1, -1);
          flipV = -1;
        }

        var scaleX = 1;
        var scaleY = 1;
        if (currentAnim.scaleX == -1) {
          ctx.scale(-1, 1);
          scaleX = -1;
        }
        if (currentAnim.scaleY == -1) {
          ctx.scale(1, -1);
          scaleY = -1;
        }

        ctx.drawImage(document.getElementById("cell-num-" + cellIndex), offsetX, offsetY);
        ctx.restore();

        svgData += '<image id="' + cellIndex + '" xlink:href="' + document.getElementById("cell-num-" + cellIndex).toDataURL() + '" height="' + cell.sizeY + '" width="' + cell.sizeX + '" y="' + (offsetY) + '" x="' + (offsetX) +
          '" transform="translate(' + (dx) + ' ' + -(dy) + ') rotate(' + -angle + ') scale(' + flipH + ' ' + flipV + ') scale(' + scaleX + ' ' + scaleY + ')"/>\n';

        for (var i = 0; i < px.length; i++) {
          svgData += '</g>';
        }
      }
      return svgData;
    }

    function drawGrid(ctx, width, height, spacing) {
      ctx.beginPath();
      for (var x = -width; x < width; x += spacing) {
        ctx.moveTo(x, -height);
        ctx.lineTo(x, height);
      }
      for (var y = -height; y < height; y += spacing) {
        ctx.moveTo(-width, y);
        ctx.lineTo(width, y);
      }
      ctx.strokeStyle = "gray";
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -height);
      ctx.lineTo(0, height);
      ctx.moveTo(-width, 0);
      ctx.lineTo(WIDTH, 0);
      ctx.strokeStyle = "blue";
      ctx.stroke();
    }

    function drawSVG(ctx, svgData, pose) {
      var header = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + WIDTH + '" height="' + HEIGHT + '" viewBox="' + -(WIDTH / 2 + STARTX) + ' ' + -(HEIGHT / 2 + STARTY) + ' ' + WIDTH + ' ' + HEIGHT +
        '">\n';
      var uri = encodeURIComponent(header + svgData + '</svg>');
      var dataURL = 'data:image/svg+xml,' + uri;

      var img = new Image();
      img.onload = function() {
        ctx.drawImage(img, -WIDTH / 2, -HEIGHT / 2);
      }
      img.src = dataURL;

      return dataURL;
    }

    function assembleSprite(gridOpt = false) {
      for (var m = 0; m < Object.keys(initialAnimeJSON).length; m++) {
        var animePackName = Object.keys(initialAnimeJSON)[m];
        console.log('\n\n');
        console.log('[animePackName]', animePackName);

        var parts = partsJSON[animePackName];

        var anim = initialAnimeJSON[animePackName];
        console.log('[animeDataArray]', anim);

        for (var n = 0; n < anim.length; n++) {
          var pose = Object.keys(anim[n])[0];
          console.log('[pose] ' + pose);

          var header = document.createElement('h1');
          header.innerHTML = pose;
          document.getElementById('assembled-wrapper').appendChild(header);

          var canvasCtn = document.createElement('div');
          canvasCtn.classList.add('ctn');
          document.getElementById('assembled-wrapper').appendChild(canvasCtn);

          var canvas = document.createElement('canvas');
          canvas.id = 'sprite-' + pose;
          canvas.width = WIDTH;
          canvas.height = HEIGHT;
          canvas.style.border = '1px solid #000';
          canvasCtn.appendChild(canvas);

          var ctx = canvas.getContext("2d");
          ctx.translate(WIDTH / 2, HEIGHT / 2);
          if (gridOpt) {
            drawGrid(ctx, WIDTH, HEIGHT, 10);
          }
          ctx.translate(STARTX, STARTY);

          var animation = anim[n][pose];

          // generate parent data
          var parentPosition = [];
          parentPosition[-1] = {
            'x': [0],
            'y': [0],
            'rotationZ': [0],
            'scaleX': [1],
            'scaleY': [1]
          };
          for (var i = 0; i < animation.length; i++) {
            var currentAnim = animation[i];
            var part = parts[i];

            var xpos = currentAnim.posX / 10;
            var ypos = currentAnim.posY / 10;
            var rotationZ = currentAnim.rotationZ;
            var scaleX = currentAnim.scaleX;
            var scaleY = currentAnim.scaleY;

            // parts will be drawn in the order they appear in the array
            // drawPartAt(animation, i, parentPosition[part.parentIndex], parts, ctx);
            // console.log(animation, i, parentPosition[part.parentIndex], parts, ctx);

            // concat the position data to the corresponding parent array
            parentPosition[i] = {
              'x': parentPosition[part.parentIndex].x.concat([xpos]),
              'y': parentPosition[part.parentIndex].y.concat([ypos]),
              'rotationZ': parentPosition[part.parentIndex].rotationZ.concat([rotationZ]),
              'scaleX': parentPosition[part.parentIndex].scaleX.concat([scaleX]),
              'scaleY': parentPosition[part.parentIndex].scaleY.concat([scaleY])
            }
          }
          // console.log(parentPosition);

          // get the drawing order of the parts
          var firstFrame = framesJSON[animePackName][n][pose][0];
          var drawOrder = [];
          for (var i = 0; i < firstFrame.length; i++) {
            drawOrder.push(firstFrame[i].index);
          }
          console.log('[drawOrder]', drawOrder);

          // draw the parts to canvas and build the svg
          var svgData = '';
          for (var j = 0; j < animation.length; j++) {
            var i = drawOrder[j];

            var currentAnim = animation[i];
            var part = parts[i];

            svgData += drawPartAt(animation, i, parentPosition[part.parentIndex], parts, ctx);
            // console.log(animation, i, parentPosition[part.parentIndex], parts, ctx);
          }

          // download canvas as .PNG
          canvasCtn.insertBefore(document.createElement('br'), canvasCtn.childNodes[0]);
          var dataURL = document.getElementById('sprite-' + pose).toDataURL();
          var a = document.createElement("a");
          a.href = dataURL;
          a.download = filename.substring(0, filename.lastIndexOf('.')) + '_' + pose + ".png";
          a.innerHTML = 'DOWNLOAD .PNG';
          a.classList.add('btn');
          canvasCtn.insertBefore(a, canvasCtn.childNodes[0]);

          // draw svg to canvas
          var canvasCtn = document.createElement('div');
          canvasCtn.classList.add('ctn');
          document.getElementById('assembled-wrapper').appendChild(canvasCtn);

          var canvas = document.createElement('canvas');
          canvas.id = 'svg-sprite-' + pose;
          canvas.width = WIDTH;
          canvas.height = HEIGHT;
          canvas.style.border = '1px solid #000';
          canvasCtn.appendChild(canvas);

          var svgCtx = canvas.getContext("2d");
          svgCtx.translate(WIDTH / 2, HEIGHT / 2);
          if (gridOpt) {
            drawGrid(svgCtx, WIDTH, HEIGHT, 10);
          }
          // svgCtx.translate(STARTX, STARTY);

          var dataURL = drawSVG(svgCtx, svgData, pose);

          // download as .SVG
          canvasCtn.insertBefore(document.createElement('br'), canvasCtn.childNodes[0]);
          var a = document.createElement("a");
          a.href = dataURL;
          a.download = filename.substring(0, filename.lastIndexOf('.')) + '_' + pose + ".svg";
          a.innerHTML = 'DOWNLOAD .SVG';
          a.classList.add('btn');
          canvasCtn.insertBefore(a, canvasCtn.childNodes[0]);

          document.getElementById('assembled-wrapper').appendChild(document.createElement('br'));
          document.getElementById('assembled-wrapper').appendChild(document.createElement('hr'));

        }
        console.log('\n\n');
      }
    }






    document.addEventListener("DOMContentLoaded", function(event) {
      document.getElementById('title').innerHTML = filename;

      var count = 0;

      function loaded() {
        if (count == textureURLArray.length) {
          drawCells();
          assembleSprite();
        }
      }

      // load sprite sheets
      for (var i = 0; i < textureURLArray.length; i++) {
        var imgCtn = document.createElement('div');
        imgCtn.classList.add('ctn');
        var imgName = document.createElement('div');
        imgName.innerHTML = textureURLArray[i];
        imgCtn.appendChild(imgName);

        var img = new Image();

        img.onload = function() {
          console.log('[OK]', this.id);
          count++;
          loaded();
        };
        img.onerror = function() {
          console.log('[X]', this.id);
          count++;
          loaded();
        }
        img.src = textureURLArray[i];
        img.id = textureURLArray[i].substring(textureURLArray[i].lastIndexOf('/') + 1, textureURLArray[i].lastIndexOf('.'));
        img.style.border = '1px solid #000';

        imgCtn.appendChild(img);
        document.getElementById('sprite-sheet-wrapper').appendChild(imgCtn);
      }

      var pivotOpt = false;
      var gridOpt = false;

      function redraw() {
        WIDTH = parseInt(document.getElementById('width-input').value);
        HEIGHT = parseInt(document.getElementById('height-input').value);

        STARTX = parseInt(document.getElementById('x-input').value);
        STARTY = -parseInt(document.getElementById('y-input').value);

        document.getElementById('cells-wrapper').innerHTML = '';
        document.getElementById('assembled-wrapper').innerHTML = '';
        drawCells(pivotOpt);
        assembleSprite(gridOpt);
      }

      document.getElementById('pivot-btn').addEventListener('click', function() {
        pivotOpt = !pivotOpt;
        redraw();
        pivotOpt ? document.getElementById('pivot-btn').innerHTML = 'HIDE PIVOT' : document.getElementById('pivot-btn').innerHTML = 'SHOW PIVOT';
      });

      document.getElementById('grid-btn').addEventListener('click', function() {
        document.getElementById('assembled-wrapper').innerHTML = '';
        gridOpt = !gridOpt;
        assembleSprite(gridOpt);
        gridOpt ? document.getElementById('grid-btn').innerHTML = 'HIDE GRID' : document.getElementById('grid-btn').innerHTML = 'SHOW GRID';
      });

      document.getElementById('resize-btn').addEventListener('click', function() {
        redraw();
      });

      var textInputs = document.getElementsByTagName('input');
      for(var k = 0; k < textInputs.length; k++){
        textInputs[k].addEventListener('keypress', function (e) {
          if (e.key === 'Enter') {
            redraw();
          }
        });
      }

    });
  </script>
</body>

</html>
