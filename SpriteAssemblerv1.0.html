<html>

<head>
  <!-- load js files generated by convertSSBP.py -->
  <script src="cellsArray.js"></script>
  <script src="textureURLArray.js"></script>
  <script src="partsJSON.js"></script>
  <script src="initialAnimeJSON.js"></script>
  <script src="framesJSON.js"></script>

  <style>
    body {
      font-family: sans-serif;
    }

    hr {
      height: 0;
      border: 0;
      border-top: 6px solid #000;
    }

    .ctn {
      display: inline-block;
      margin: 15px;
    }

    .btn {
      background-color: #000;
      color: #fff;
      border: 0;
      padding: 10px 30px;
      font-size: 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      white-space: nowrap;
    }

    .btn:hover {
      background-color: lime;
      color: #000;
    }
  </style>
</head>

<body>
  <h1 id="title"></h1>
  <hr>
    <div style="display: none">
      <h1> TEXTURES </h1>
      <div id="sprite-sheet-wrapper"></div>
      <br>
      <hr>

      <h1> CELLS </h1>
      <button id="pivot-btn" class="btn"> SHOW PIVOT </button>
      <br>
      <br>
      <div id="cells-wrapper"></div>
      <br>
      <hr>
      <br>
    </div>
  <button id="grid-btn" class="btn"> SHOW GRID </button>
  <br>
  <br> Width: <input id="width-input" type="text" value="800"> Height: <input id="height-input" type="text" value="800">
  <br>
  <br> X: <input id="x-input" type="text" value="0"> Y: <input id="y-input" type="text" value="0">
  <br>
  <br>
  <button id="resize-btn" class="btn"> RESIZE </button><br>
  <br>
  <select id="pose">
  </select>
  <div id="assembled-wrapper"></div>

  <script>
    var WIDTH = parseInt(document.getElementById('width-input').value);
    var HEIGHT = parseInt(document.getElementById('height-input').value);

    var STARTX = parseInt(document.getElementById('x-input').value);
    var STARTY = -parseInt(document.getElementById('y-input').value);

    var cells = cellsArray;
    
    var stopplaying = 0;
    var lastanimeid = -1;

    function drawCells(showPivot = false) {
      for (var i = 0; i < cellsArray.length; i++) {
        var cellCtn = document.createElement('div');
        cellCtn.classList.add('ctn');
        document.getElementById('cells-wrapper').appendChild(cellCtn);

        var num = document.createElement('h2');
        num.innerHTML = i;
        cellCtn.appendChild(num);

        var cellName = document.createElement('div');
        cellName.innerHTML = cellsArray[i]["name"];
        cellCtn.appendChild(cellName);

        var canvas = document.createElement('canvas');
        canvas.id = 'cell-num-' + i;
        canvas.width = cellsArray[i].sizeX;
        canvas.height = cellsArray[i].sizeY;
        canvas.style.border = '1px solid #000';
        cellCtn.appendChild(canvas);

        var ctx = canvas.getContext("2d");

        var imagePath = cellsArray[i].cellMapData.imagePath;
        var texId = imagePath.substring(imagePath.lastIndexOf('/') + 1, imagePath.lastIndexOf('.'));
        var tex = document.getElementById(texId);

        try {
          ctx.drawImage(tex, -cellsArray[i]["posX"], -cellsArray[i]["posY"]);

          if (showPivot) {
            var cx = cellsArray[i].sizeX / 2;
            var cy = cellsArray[i].sizeY / 2;

            var pivotX = cellsArray[i].pivotX * cx * 2;
            var pivotY = cellsArray[i].pivotY * cy * 2;

            ctx.translate(cx, cy);
            ctx.beginPath();
            ctx.arc(pivotX, pivotY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "lime";
            ctx.fill();

            ctx.beginPath();
            ctx.arc(pivotX, pivotY, 3, 0, 2 * Math.PI);
            ctx.fillStyle = "fuchsia";
            ctx.fill();
          }

        } catch (error) {
          console.log('[drawCell() Err]: texId=', texId);
        }
      }
    }

    function drawPartAt(animation, animObj, parentPosition, parts, ctx) {
      if (!animObj.pos_x) animObj.pos_x=0;
      if (!animObj.pos_y) animObj.pos_y=0;
      if (!animObj.rotation_z) animObj.rotation_z=0;
      var animIndex = animObj.index;
      
      var currentAnim = animation[animIndex];
      var part = parts[animIndex];
      var cellIndex = currentAnim.cellIndex;

      var dx = currentAnim.posX / 10;
      var dy = currentAnim.posY / 10;
      var angle = currentAnim.rotationZ;

      if (cellIndex > -1 && part.partType != 0 && !(currentAnim.flags & 1)) {
        var cell = cells[cellIndex];

        // set part's origin at center of cell
        var cx = -cell.sizeX / 2;
        var cy = -cell.sizeY / 2;

        // get pivot position
        var pivotX = cell.pivotX * cell.sizeX;
        var pivotY = cell.pivotY * cell.sizeY;

        // set part's origin at pivot
        var offsetX = cx - pivotX;
        var offsetY = cy - pivotY;

        ctx.save();

        for (var i = 0; i < parentPosition.length; i++) {
          if (parentPosition[i] == -1) continue;
          
          var px = animation[parentPosition[i]].posX/10;
          var py = animation[parentPosition[i]].posY/10;
          var pAngle = animation[parentPosition[i]].rotationZ;
          var pScaleX = animation[parentPosition[i]].scaleX;
          var pScaleY = animation[parentPosition[i]].scaleY;

          ctx.translate(px, -py);
          ctx.rotate(-pAngle * Math.PI / 180);

          var scaleX = 1;
          var scaleY = 1;
          if (pScaleX[i] == -1) {
            ctx.scale(-1, 1);
            scaleX = -1;
          }
          if (pScaleY[i] == -1) {
            ctx.scale(1, -1);
            scaleY = -1;
          }

        }
        
        ctx.translate(dx, -dy);
        ctx.rotate(-angle * Math.PI / 180);

        var flipH = 1;
        var flipV = 1;
        if (currentAnim.flags & (1 << 1)) {
          ctx.scale(-1, 1);
          flipH = -1;
        }
        if (currentAnim.flags & (1 << 2)) {
          ctx.scale(1, -1);
          flipV = -1;
        }

        var scaleX = 1;
        var scaleY = 1;
        if (currentAnim.scaleX == -1) {
          ctx.scale(-1, 1);
          scaleX = -1;
        }
        if (currentAnim.scaleY == -1) {
          ctx.scale(1, -1);
          scaleY = -1;
        }

        ctx.drawImage(document.getElementById("cell-num-" + cellIndex), offsetX, offsetY);
        ctx.restore();
      }
    }

    function drawGrid(ctx, width, height, spacing) {
      ctx.beginPath();
      for (var x = -width; x < width; x += spacing) {
        ctx.moveTo(x, -height);
        ctx.lineTo(x, height);
      }
      for (var y = -height; y < height; y += spacing) {
        ctx.moveTo(-width, y);
        ctx.lineTo(width, y);
      }
      ctx.strokeStyle = "gray";
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -height);
      ctx.lineTo(0, height);
      ctx.moveTo(-width, 0);
      ctx.lineTo(WIDTH, 0);
      ctx.strokeStyle = "blue";
      ctx.stroke();
    }

    function assembleSprite(gridOpt = false) {
        var poselist = document.getElementById("pose");
        
        for (var m = 0; m < Object.keys(initialAnimeJSON).length; m++) {
            var animePackName = Object.keys(initialAnimeJSON)[m];

            //if (animePackName != 'chara_15_rod_m') continue;
            //if (animePackName != 'chara_51_yui') continue;//TODO

            console.log('[animePackName]', animePackName);

            var parts = partsJSON[animePackName];

            var anim = initialAnimeJSON[animePackName];
            console.log('[animeDataArray]', anim);
            for (var n = 0; n < anim.length; n++) {
              var pose = Object.keys(anim[n])[0];
              console.log('[pose] ' + pose);
              //if (pose != 'walk') continue;
              //if (pose != 'gesture') continue;//TODO
              var option = document.createElement("option");
              option.text = pose;
              option.value = animePackName+','+n;
              poselist.add(option);
              //document.getElementById('assembled-wrapper').appendChild(document.createElement('br'));
              //document.getElementById('assembled-wrapper').appendChild(document.createElement('hr'));
            }
        }
        var canvasCtn = document.createElement('div');
        canvasCtn.classList.add('ctn');
        document.getElementById('assembled-wrapper').appendChild(canvasCtn);

        var canvas = document.createElement('canvas');
        canvas.id = 'sprite-' + pose;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        canvas.style.border = '1px solid #000';
        canvasCtn.appendChild(canvas);

        var ctx = canvas.getContext("2d");
        ctx.translate(WIDTH / 2, HEIGHT / 2);
        if (gridOpt) {
            drawGrid(ctx, WIDTH, HEIGHT, 10);
        }
        ctx.translate(STARTX, STARTY);

        poselist.addEventListener("change", function(){
            stopplaying = lastanimeid;
            setPose(gridOpt, parts, ctx);
        });
    }

    function setPose(gridOpt, parts, ctx){
        /*var header = document.createElement('h1');
        header.innerHTML = pose;
        document.getElementById('assembled-wrapper').appendChild(header);*/
        
        var poselist = document.getElementById("pose");
        var pose = poselist.options[poselist.selectedIndex].text;
        var n = poselist.options[poselist.selectedIndex].value.split(',')[1];
        var animePackName = poselist.options[poselist.selectedIndex].value.split(',')[0];
        var anim = initialAnimeJSON[animePackName];

        var animation = anim[n][pose];

        lastanimeid = createanime(parts, animation, animePackName, n, pose, ctx);
    }

    function createanime(parts, animation, animePackName, n, pose, ctx){
        var start = null;
        var state = 0;
        var drawOrder = [];
        var orderMapping = {};
        
        // generate parent data
        var parentPosition = [];
        parentPosition[-1]=[];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            parentPosition[i] = parentPosition[part.parentIndex].concat(i);
        }
        var oldAnimation = animation.slice();
        function step(timestamp) {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, 800, 800);
            ctx.restore();

            var firstFrame = framesJSON[animePackName][n][pose][state];
            var drawOrderSize = 0;
            //update data
            for (var i = 0; i < firstFrame.length; i++) {
                //drawOrder.push(firstFrame[i].index);
                if (orderMapping[firstFrame[i].index]){
                    drawOrder[orderMapping[firstFrame[i].index]] = firstFrame[i];
                }else{
                    drawOrder.push(firstFrame[i]);
                    orderMapping[firstFrame[i].index.toString()] = i;
                }   
            }
            animation = oldAnimation.slice();
            //update position
            for (var j = 0; j < animation.length; j++) {
                var obj = drawOrder[j];
                var i = obj.index;

                var currentAnim = animation[i];
                var part = parts[i];
                
                //if (obj.index == 17||obj.index == 18||obj.index == 19)
                //console.error(i+': '+/*currentAnim.posX+':'+obj.pos_x+' '+currentAnim.posY+':'+obj.pos_y+*/
                //    ' '+currentAnim.rotationZ+':'+obj.rotation_z)
                
                if (obj.pos_x){
                    currentAnim.posX=obj.pos_x*10;
                }
                if (obj.pos_y){
                    currentAnim.posY=obj.pos_y*10;
                }
                if (obj.rotation_z){
                    currentAnim.rotationZ=obj.rotation_z;
                }
            }
            if (state < 0){}else{
                // draw the parts to canvas and build the svg
                for (var j = 0; j < parts.length; j++) {
                    var obj = drawOrder[j];
                    var i = obj.index;

                    var currentAnim = animation[i];
                    var part = parts[i];
                    
                    if (part){
                    //if (i==18||i==19){
                        //console.error(i);
                        drawPartAt(animation, obj, parentPosition[part.parentIndex], parts, ctx);
                    //}
                    }
                }
            }
            state += 1;
            
            if (state >= framesJSON[animePackName][n][pose].length){state = 0;}
            //else
                setTimeout(function(){
                    if (stopplaying != randomid)
                        window.requestAnimationFrame(step);
                }, 1000/30);
        }
        window.requestAnimationFrame(step);
        var randomid = Math.floor(Math.random()*100);
        return randomid;
    }



    document.addEventListener("DOMContentLoaded", function(event) {
      document.getElementById('title').innerHTML = filename;

      var count = 0;

      function loaded() {
        if (count == textureURLArray.length) {
          drawCells();
          assembleSprite();
        }
      }

      // load sprite sheets
      for (var i = 0; i < textureURLArray.length; i++) {
        var imgCtn = document.createElement('div');
        imgCtn.classList.add('ctn');
        var imgName = document.createElement('div');
        imgName.innerHTML = textureURLArray[i];
        imgCtn.appendChild(imgName);

        var img = new Image();

        img.onload = function() {
          console.log('[OK]', this.id);
          count++;
          loaded();
        };
        img.onerror = function() {
          console.log('[X]', this.id);
          count++;
          loaded();
        }
        img.src = textureURLArray[i];
        img.id = textureURLArray[i].substring(textureURLArray[i].lastIndexOf('/') + 1, textureURLArray[i].lastIndexOf('.'));
        img.style.border = '1px solid #000';

        imgCtn.appendChild(img);
        document.getElementById('sprite-sheet-wrapper').appendChild(imgCtn);
      }

      var pivotOpt = false;
      var gridOpt = false;

      function redraw() {
        WIDTH = parseInt(document.getElementById('width-input').value);
        HEIGHT = parseInt(document.getElementById('height-input').value);

        STARTX = parseInt(document.getElementById('x-input').value);
        STARTY = -parseInt(document.getElementById('y-input').value);

        document.getElementById('cells-wrapper').innerHTML = '';
        document.getElementById('assembled-wrapper').innerHTML = '';
        drawCells(pivotOpt);
        assembleSprite(gridOpt);
      }

      document.getElementById('pivot-btn').addEventListener('click', function() {
        pivotOpt = !pivotOpt;
        redraw();
        pivotOpt ? document.getElementById('pivot-btn').innerHTML = 'HIDE PIVOT' : document.getElementById('pivot-btn').innerHTML = 'SHOW PIVOT';
      });

      document.getElementById('grid-btn').addEventListener('click', function() {
        document.getElementById('assembled-wrapper').innerHTML = '';
        gridOpt = !gridOpt;
        assembleSprite(gridOpt);
        gridOpt ? document.getElementById('grid-btn').innerHTML = 'HIDE GRID' : document.getElementById('grid-btn').innerHTML = 'SHOW GRID';
      });

      document.getElementById('resize-btn').addEventListener('click', function() {
        redraw();
      });

      var textInputs = document.getElementsByTagName('input');
      for(var k = 0; k < textInputs.length; k++){
        textInputs[k].addEventListener('keypress', function (e) {
          if (e.key === 'Enter') {
            redraw();
          }
        });
      }

    });
  </script>
</body>

</html>
